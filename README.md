# CLR(1) парсер

Реализация CLR(1) парсера на языке C++.

## Ввод грамматики и парсинг слов:

1. Вводите правила грамматики построчно в формате «S->AbCd» без пробелов.
2. Терминалом может быть любой символ, кроме прописных английских букв, '$', '.' и '@'.
3. Для пустого терминала используйте '~'.
4. После всех правил укажите стартовый нетерминал.
5. Построчно вводите слова, которые нужно проверить.
6. По окончании работы с парсером напишите «[STOP]».

Пример ввода:
```
S->AA
A->aA
A->b
S
aaabba
aabab
aababaaa
abcd
[STOP]
```

## Что такое CLR(1) парсер?
[Wikipedia:](https://en.wikipedia.org/wiki/Canonical_LR_parser) "В информатике **канонический LR парсер** или **LR(1) парсер** - это LR(k) парсер для k = 1, т.е. с возможностью просмотра на один символ вперед. Особенностью этого синтаксического анализатора является то, что любая LR(k) грамматика с k > 1 может быть преобразована в LR(1) грамматику. Однако для уменьшения k требуются обратные подстановки, и по мере увеличения количества обратных подстановок грамматика может быстро стать большой, повторяющейся и трудной для понимания. LR(k) может работать со всеми детерминированными контекстно-свободными языками."

# Предобработка
Алгоритм реализован с помощью класса Algo. Предобработка состоит из нескольких этапов:
- [ ] [Построение автомата по грамматике](#построение-автомата-по-грамматике)
- [ ] [Построение таблицы по автомату](#построение-таблицы-по-автомату)

## Построение автомата по грамматике

Метод CalculateStates строит автомат по заданной грамматике, необходимый для создания таблицы парсинга:
1. Создаётся нулевое состояние, содержащие все правила с точкой (Items), которые получаются из стартового нетерминала и всех нетерминалов, стоящих на первой позиции в правилах.
2. Аналогично для каждого нетерминала и терминала создаются состояния, соответствующие операциям Goto и Shift, а также добавляются переходы к ним.
3. Построение продолжается до тех пор, пока не перестанут появляться новые состояния.

    
Состояние, содержащее единственный Item, в левой части которого стоит добавленный стартовый нетерминал (@) и в правой части "прочитанный" стартовый нетерминал, указанный пользователем, является завершающим. 

## Построение таблицы по автомату

Метод MakeTable строит таблицу парсинга, необходимую для метода Predict:
1. Каждому состоянию по его вектору переходов сопоставлются другие состояния.
2. Для тех Items, в которых правая часть полностью "прочитана", ставится в соответствие символам из lookahead правила, по которым будет происходить свёртка.
3. В случае Reduce/Reduce или Shift/Reduce конфликтов выбрасывается исключение типа GrammarException.

# Проверка принадлежности слова языку, задаваемого данной контекстно-свободной грамматикой.

Метод Predict принимает на вход слово для проверки и массив, куда будут записываться правила, по которым строится правостороннее дерево разбора.
1. К слову добавляется символ '$', отвечающий за конец слова.
2. В стек добавляются символы слова и номера состояний, в которые выполняется операця Shift, до тех пор, пока переходом не будет являться правило грамматики. В этот момент оно также добавляется в массив дерева разбора.
3. Из стека удаляются элементы, до тех пор, пока не будут найдены все составляющие правой части данного правила в правильном порядке.
4. В стек добавляется нетерминал левой части данного правила.
5. Проверка завершается успешно, если в стеке останется число, отвечающее нулевому состоянию автомата, и добавленный стартовый нетерминал.
6. Во случаях полного опустошения стека, отсутствия символов слова в таблице или прочтения слова без условия предыдущего пункта, проверка считается неуспешной.  

## О сложности LR парсеров по сравнению с другими алгоритмами парсинга
LR парсеры являются детерминированными; они производят единственный правильный разбор без предугадываний или бэктрекинга, за линейное время. Это идеально подходит для компьютерных языков, но LR парсеры не подходят для человеческих языков, которым нужны более гибкие, но неизбежно более медленные методы. Некоторые методы, которые могут разбирать произвольные контекстно-свободные языки (например, Cocke-Younger-Kasami, Earley, GLR), имеют наихудшую производительность O(<img src="https://render.githubusercontent.com/render/math?math=n^{3}">) времени. Другие методы, которые делают бэктрекинг или дают несколько разборов, могут даже занимать экспоненциальное время, если они плохо угадывают.
